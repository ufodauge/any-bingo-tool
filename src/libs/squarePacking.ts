// basically generated by gemini 3
type Rect = {
  width: number;
  height: number;
  // デバッグや描画のために座標を持たせることも可能ですが、
  // 今回はサイズリストのみが必要なため省略します。
};

type Square = {
  size: number;
};

/**
 * メイン関数: 正方形充填アルゴリズム
 */
export function generateRandomSquares(
  n: number,
  maxSize: number,
  rng: () => number
): Square[] {
  // --- バリデーション ---
  if (!Number.isInteger(n) || !Number.isInteger(maxSize)) {
    throw new Error('Inputs must be integers.');
  }

  const MIN_SIZE = 1;
  if (MIN_SIZE > maxSize) {
    throw new Error(`maxSize (${maxSize}) should be upper than or equal to 1.`);
  }

  const results: Square[] = [];
  const stack: Rect[] = [{ width: n, height: n }];

  let loopCount = 0;
  const maxIter = n * n;
  while (stack.length > 0) {
    if (++loopCount > maxIter) {
      throw Error(`Internal logic error: Max iterations reached.`);
    }

    const rect = stack.pop();
    if (rect === undefined) {
      throw Error(`Invalid operation error: stack is already empty.`);
    }

    const { width, height } = rect;
    if (width <= 0 || height <= 0) {
      throw Error(`Invalid operation error: invalid size rect is poped.`);
    }

    const size =
      width <= MIN_SIZE || height <= MIN_SIZE
        ? MIN_SIZE
        : Math.max(
            Math.floor(rng() * Math.min(width, height, maxSize + 1)),
            MIN_SIZE
          );

    results.push({ size });

    // --- 3. 残りの領域をスタックに追加 ---
    const remainingWidth = width - size;
    const remainingHeight = height - size;

    // 縦分割
    if (rng() > 0.5) {
      // 右側の領域: (幅 - size) x 高さ
      if (remainingWidth >= MIN_SIZE) {
        stack.push({ width: remainingWidth, height: height });
      }

      // 正方形の直下の領域: size x (高さ - size)
      if (remainingHeight >= MIN_SIZE) {
        stack.push({ width: size, height: remainingHeight });
      }
    }
    // 横分割
    else {
      // 正方形の真右の領域: size x (幅 - size)
      if (remainingWidth >= MIN_SIZE) {
        stack.push({ width: remainingWidth, height: size });
      }

      // 下側の領域: 幅 x (高さ - size)
      if (remainingHeight >= MIN_SIZE) {
        stack.push({ width: width, height: remainingHeight });
      }
    }
  }

  return results;
}
